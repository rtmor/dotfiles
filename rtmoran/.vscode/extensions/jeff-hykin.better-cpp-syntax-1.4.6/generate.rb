require_relative './readable_regex.rb'
include GrammarHelper
require_relative './cpp_tokens.rb'

# todo
    # create the And() and Or() functions and rework the pattern_sequence args for SimpleTag
    # fix sizeof, alignas and similar
    # fix initializer list "functions"
    # fix the ... inside of macros
    # replace all strings with regex literals
    # add adjectives:
        # canHaveBrackets
        # mustHaveBrackets
        # canBeModifier
        # canHaveParaentheses
        # canBeOnRightHandSide
        # cantHaveParaentheses
        # cannotBeFunctionName
        # cannotBeVariableName
    # have all patterns with keywords be dynamically generated
    # lambda -> 
    # operator with words/space
    # add user-defined constants variable.other.constant.user-defined.cpp

# Edgecases to remember
    # ... inside of catch()
    # operator overload for user-defined literal 
    # labels for goto
    # lambda syntax

cpp_grammar = Grammar.new(
    name:"C++", 
    scope_name: "source.cpp",
    version: "https://github.com/jeff-hykin/cpp-textmate-grammar/blob/master/generate.rb",
    information_for_contributors: [
        "This code was auto generated by a much-more-readble ruby file: https://github.com/jeff-hykin/cpp-textmate-grammar/blob/master/generate.rb",
        "It is a lot easier to modify the ruby file and have it generate the rest of the code",
        "Also the ruby source is very open to merge requests, so please make one if something could be improved",
        "This file essentially an updated/improved fork of the atom syntax https://github.com/atom/language-c/blob/master/grammars/c%2B%2B.cson",
    ],
)


# type modifiers
with_reference   = maybe(@spaces).then(  /&/.or /&&/  ).maybe(@spaces)
with_dereference = maybe(@spaces).zeroOrMoreOf( /\*/  ).maybe(@spaces)

# misc
builtin_c99_function_names = /(_Exit|(?:nearbyint|nextafter|nexttoward|netoward|nan)[fl]?|a(?:cos|sin)h?[fl]?|abort|abs|asctime|assert|atan(?:[h2]?[fl]?)?|atexit|ato[ifl]|atoll|bsearch|btowc|cabs[fl]?|cacos|cacos[fl]|cacosh[fl]?|calloc|carg[fl]?|casinh?[fl]?|catanh?[fl]?|cbrt[fl]?|ccosh?[fl]?|ceil[fl]?|cexp[fl]?|cimag[fl]?|clearerr|clock|clog[fl]?|conj[fl]?|copysign[fl]?|cosh?[fl]?|cpow[fl]?|cproj[fl]?|creal[fl]?|csinh?[fl]?|csqrt[fl]?|ctanh?[fl]?|ctime|difftime|div|erfc?[fl]?|exit|fabs[fl]?|exp(?:2[fl]?|[fl]|m1[fl]?)?|fclose|fdim[fl]?|fe[gs]et(?:env|exceptflag|round)|feclearexcept|feholdexcept|feof|feraiseexcept|ferror|fetestexcept|feupdateenv|fflush|fgetpos|fgetw?[sc]|floor[fl]?|fmax?[fl]?|fmin[fl]?|fmod[fl]?|fopen|fpclassify|fprintf|fputw?[sc]|fread|free|freopen|frexp[fl]?|fscanf|fseek|fsetpos|ftell|fwide|fwprintf|fwrite|fwscanf|genv|get[sc]|getchar|gmtime|gwc|gwchar|hypot[fl]?|ilogb[fl]?|imaxabs|imaxdiv|isalnum|isalpha|isblank|iscntrl|isdigit|isfinite|isgraph|isgreater|isgreaterequal|isinf|isless(?:equal|greater)?|isw?lower|isnan|isnormal|isw?print|isw?punct|isw?space|isunordered|isw?upper|iswalnum|iswalpha|iswblank|iswcntrl|iswctype|iswdigit|iswgraph|isw?xdigit|labs|ldexp[fl]?|ldiv|lgamma[fl]?|llabs|lldiv|llrint[fl]?|llround[fl]?|localeconv|localtime|log[2b]?[fl]?|log1[p0][fl]?|longjmp|lrint[fl]?|lround[fl]?|malloc|mbr?len|mbr?towc|mbsinit|mbsrtowcs|mbstowcs|memchr|memcmp|memcpy|memmove|memset|mktime|modf[fl]?|perror|pow[fl]?|printf|puts|putw?c(?:har)?|qsort|raise|rand|remainder[fl]?|realloc|remove|remquo[fl]?|rename|rewind|rint[fl]?|round[fl]?|scalbl?n[fl]?|scanf|setbuf|setjmp|setlocale|setvbuf|signal|signbit|sinh?[fl]?|snprintf|sprintf|sqrt[fl]?|srand|sscanf|strcat|strchr|strcmp|strcoll|strcpy|strcspn|strerror|strftime|strlen|strncat|strncmp|strncpy|strpbrk|strrchr|strspn|strstr|strto[kdf]|strtoimax|strtol[dl]?|strtoull?|strtoumax|strxfrm|swprintf|swscanf|system|tan|tan[fl]|tanh[fl]?|tgamma[fl]?|time|tmpfile|tmpnam|tolower|toupper|trunc[fl]?|ungetw?c|va_arg|va_copy|va_end|va_start|vfw?printf|vfw?scanf|vprintf|vscanf|vsnprintf|vsprintf|vsscanf|vswprintf|vswscanf|vwprintf|vwscanf|wcrtomb|wcscat|wcschr|wcscmp|wcscoll|wcscpy|wcscspn|wcsftime|wcslen|wcsncat|wcsncmp|wcsncpy|wcspbrk|wcsrchr|wcsrtombs|wcsspn|wcsstr|wcsto[dkf]|wcstoimax|wcstol[dl]?|wcstombs|wcstoull?|wcstoumax|wcsxfrm|wctom?b|wmem(?:set|chr|cpy|cmp|move)|wprintf|wscanf)/
# 
# Numbers
# 
    # TODO: improve tagging for:
        # tag the E in 1001E1101
        # fix the F in 0x0.5p10F
    octal_pattern = lookBehindToAvoid(/['\.\w]/).then(/0/).lookAheadFor(@digit)
    binary_pattern = lookBehindToAvoid(@standard_character).then(/0/.then(/b/.or(/B/))).lookAheadFor(@digit)
    hex_pattern  = lookBehindToAvoid(@standard_character).then(/0/.then(/x/.or(/X/)))
    non_hex_non_octal_units = /[^\d\.a-fA-F]+/
                    hex_start_pattern = /0(?:x|X)/
                    hex_content_pattern = /[0-9a-fA-F](?:[0-9a-fA-F']*[0-9a-fA-F'])?/
                full_hex_pattern = hex_start_pattern.then(hex_content_pattern)
                    binary_start_pattern = /0(?:b|B)/
                    binary_content_pattern = /[01](?:[01']*[01'])?/
                full_binary_pattern = binary_start_pattern.then(binary_content_pattern)
            main_hex_or_binary_pattern = full_hex_pattern.or(full_binary_pattern)
            hexadecimal_floating_constant_pattern = /\.[\d+a-fA-F']+p[\d']+/
        full_hex_or_binary = main_hex_or_binary_pattern.maybe(hexadecimal_floating_constant_pattern)
        possible_type_endings = maybe(/L|l|UL|ul|u|U|F|f|ll|LL|ull|ULL/)
        integer_with_seperators = /[0-9]/.zeroOrMoreOf(/[0-9']*[0-9']/)
        decimal_ending = maybe(/\./.then(integer_with_seperators))
    numeric_pattern = /\b(#{-full_hex_or_binary}|((#{-integer_with_seperators}#{-decimal_ending})|(\.#{-integer_with_seperators}))((e|E)(\+|-)?#{-integer_with_seperators})?)#{-possible_type_endings}\w*/
# 
# variable
# 
# todo: make a better name for this function
variableBounds = ->(regex_pattern) do
    lookBehindToAvoid(@standard_character).then(regex_pattern).lookAheadToAvoid(@standard_character)
end
variable_name_without_bounds = /[a-zA-Z_]#{-@standard_character}*/
# word bounds are inefficient, but they are accurate
variable_name = variableBounds[variable_name_without_bounds]

# 
# Constants
# 
constants = SimpleTag.new(tag_as: "constant.language", pattern_sequence: {
    "1" => variableBounds[@cpp_tokens.that(:isLiteral)],
})
builtin_constants_1_group = variableBounds[newGroup(@cpp_tokens.that(:isLiteral))]
probably_user_constant_1_group = variableBounds[lookAheadToAvoid(@cpp_tokens.that(:isWord)).then(newGroup(/[A-Z][_A-Z]*/))]
constants_pattern_2_groups = builtin_constants_1_group.or(probably_user_constant_1_group)

# 
# Keywords and Keyword-ish things
# 
any_normal_word_operator_keyword = @cpp_tokens.that(:isOperator, :isWord, not(:isTypeCastingOperator), not(:isControlFlow))
control_flow_keywords = @cpp_tokens.that(:isControlFlow)
access_control_keywords = lookBehindToAvoid(@standard_character).then(newGroup(@cpp_tokens.that(:isAccessSpecifier))).then(/:/)
exception_keywords = variableBounds[ @cpp_tokens.that(:isExceptionRelated) ]
functional_specifiers_pre_parameters = variableBounds[ newGroup(@cpp_tokens.that(:isFunctionSpecifier)) ]
storage_specifiers = variableBounds[ newGroup(@cpp_tokens.that(:isStorageSpecifier)) ]
qualifiers_and_specifiers_post_parameters = variableBounds[ newGroup(@cpp_tokens.that(:canAppearAfterParametersBeforeBody)) ].lookAheadFor(/\s*/.then(/\{/.or(/;/).or(/[\n\r]/)))
other_keywords = variableBounds[ /(using|typedef)/ ]
memory_operators = lookBehindToAvoid(@standard_character).then( newGroup(/delete/.maybe(@spaces).then(/\[\]/).or(/delete|new/.lookAheadToAvoid(@standard_character))))

# 
# Templates
# 
    characters_in_template_call = /[\s<>,\w]/
template_call_match = /</.zeroOrMoreOf(characters_in_template_call).then(/>/).maybe(@spaces)
template_call_innards_tagger = {
    name: "meta.template.call",
    match: -template_call_match,
    captures: {
        "0" => {
            patterns: [
                {
                    include: "#storage_types-c",
                },
                {
                    include: "#constants",
                },
                {
                    include: "#scope_resolution",
                },
                {
                    match: -variable_name,
                    name: "storage.type.user-defined",
                },
                {
                    include: "#operators"
                },
                {
                    include: "#numbers-c"
                },
                {
                    include: "#strings"
                },
                {
                    match: /,/,
                    name: "punctuation.separator.comma.template.argument",
                },
            ]
        }
    }
}
template_definition_tagger = {
    begin:  lookBehindToAvoid(@standard_character).then(newGroup(/template/)).maybe(@spaces).then(newGroup(/</)),
    beginCaptures: {
        "1" => {
            name: "storage.type.template"
        },
        "2" => {
            name: "punctuation.section.angle-brackets.start.template.definition"
        }
    },
    end: ">",
    endCaptures: {
        "0" => {
            name: "punctuation.section.angle-brackets.end.template.definition"
        }
    },
    name: "template.definition",
    patterns: [
        {
            include: "#scope_resolution"
        },
        {
            include: "#template_definition_argument"
        },
        {
            include: "#template-call-innards"
        },
    ]
}
template_definition_argument = maybe(@spaces).then(newGroup(variable_name_without_bounds).or(
        # group 2 and 3 (the normal situation)
        newGroup(oneOrMoreOf(variable_name_without_bounds.then(@spaces))).then(newGroup(variable_name_without_bounds))
    ).or(
        # group 4 5 6 (ellipses)
        newGroup(variable_name_without_bounds).maybe(@spaces).then(newGroup(/\.\.\./)).maybe(@spaces).then(newGroup(variable_name_without_bounds))
    ).or(
        # groups 7 8 9 10 11
        # TODO: change this regex into readable regex, also improve its matching 
        /((?:[a-zA-Z_][a-zA-Z_0-9]*\s+)*)([a-zA-Z_][a-zA-Z_0-9]*)\s*(=)\s*(\w+)/
    ).maybe(@spaces).then(newGroup(/,/).or(lookAheadFor(/>/)))
)
template_definition_argument_tagger = {
    match: -template_definition_argument,
    captures: {
        "1" => {
            name: "storage.type.template.argument.$1"
        },
        "2" => {
            name: "storage.type.template.argument.$2"
        },
        "3" => {
            name: "entity.name.type.template"
        },
        "4" => {
            name: "storage.type.template"
        },
        "5" => {
            name: "keyword.operator.ellipsis.template.definition"
        },
        "6" => {
            name: "entity.name.type.template"
        },
        "7" => {
            name: "storage.type.template"
        },
        "8" => {
            name: "entity.name.type.template"
        },
        "9" => {
            name: "keyword.operator.assignment"
        },
        "10" => {
            name: "keyword.operator.assignment"
        },
        "11" => {
            name: "storage.type.template.argument.$10",
        },
        "12" => {
            name: "constant.language"
        },
        "13" => {
            name: "punctuation.separator.comma.template.argument"
        },
    }
}

# 
# Scope resolution
#
        one_scope_resolution = variable_name_without_bounds.maybe(@spaces).maybe(template_call_match).then(/::/)
    preceding_scopes_1_group = newGroup(zeroOrMoreOf(one_scope_resolution)).maybe(@spaces)
maybe_scope_resoleved_variable_2_groups = preceding_scopes_1_group.then(newGroup(variable_name_without_bounds)).then(@word_boundary)
preceding_scopes_4_groups = preceding_scopes_1_group.then(newGroup(variable_name_without_bounds).maybe(@spaces).maybe(newGroup(template_call_match))).then(newGroup(/::/))
scope_resolution_tagger = {
    name: "punctuation.separator.namespace.access",
    match: -preceding_scopes_4_groups,
    captures: {
        "1" => {
            name: "entity.scope",
            patterns: [
                {
                    include: "#scope_resolution"
                }
            ]
        },
        "2" => {
            name: "entity.scope.name"
        },
        "3" => {
            patterns: [
                {
                    include: "#template-call-innards"
                }
            ]
        },
        "4" => {
            name: "punctuation.separator.namespace.access"
        }
    }
}

# 
# types
# 
    symbols_that_can_appear_after_a_type = /[&*>\]\)]/
look_behind_for_type = lookBehindFor(@standard_character.and(@space).or(symbols_that_can_appear_after_a_type)).maybe(@spaces)
primitive_types = lookBehindToAvoid(@standard_character).then(@cpp_tokens.that(:isPrimitive)).lookAheadToAvoid(@standard_character)
non_primitive_types = lookBehindToAvoid(@standard_character).then(@cpp_tokens.that(not(:isPrimitive), :isType)).lookAheadToAvoid(@standard_character)
known_types = lookBehindToAvoid(@standard_character).then(@cpp_tokens.that(:isType)).lookAheadToAvoid(@standard_character)
posix_reserved_types =  variableBounds[  /[a-zA-Z_]/.zeroOrMoreOf(@standard_character).then(/_t/)  ]

# 
# Probably a parameter
#
            array_brackets = /\[\]/.maybe(@spaces)
            comma_or_closing_paraenthese = /,/.or(/\)/)
        stuff_after_a_parameter = maybe(@spaces).lookAheadFor(maybe(array_brackets).then(comma_or_closing_paraenthese))
    probably_a_normal_parameter_1_group = look_behind_for_type.then(newGroup(variable_name_without_bounds)).then(stuff_after_a_parameter)
    # below uses variable_name_without_bounds for performance (timeout) reasons
    probably_a_default_parameter_1_group = newGroup(variable_name_without_bounds).maybe(@spaces).lookAheadFor("=")
probably_a_parameter_2_groups = probably_a_default_parameter_1_group.or(probably_a_normal_parameter_1_group)
probably_a_parameter_tagger = {
    match: -probably_a_parameter_2_groups,
    captures: {
        "1" => {
            name: "variable.parameter.probably.defaulted"
        },
        "2" => {
            name: "variable.parameter.probably"
        }
    }
}

# 
# operator overload
# 
        # symbols can have spaces
        operator_symbols = maybe(@spaces).then(@cpp_tokens.that(:canAppearAfterOperatorKeyword, :isSymbol))
        # words must have spaces, the variable_name_without_bounds is for implicit overloads
        operator_wordish = @spaces.then(@cpp_tokens.that(:canAppearAfterOperatorKeyword, :isWordish).or(zeroOrMoreOf(one_scope_resolution).then(variable_name_without_bounds).maybe(@spaces).maybe(/&/)))
    after_operator_keyword = operator_symbols.or(operator_wordish)
operator_overload_4_groups = preceding_scopes_1_group.then(newGroup(/operator/)).then(newGroup(after_operator_keyword)).maybe(@spaces).then(newGroup(/\(/))
operator_overload_tagger =  {
    begin: -operator_overload_4_groups,
    beginCaptures: {
        "1" => {
            name: "entity.scope"
        },
        "2" => {
            name: "entity.name.operator.overload"
        },
        "3" => {
            name: "entity.name.operator.overloadee"
        },
        "4" => {
            name: "punctuation.section.parameters.begin.bracket.round"
        }
    },
    end: -/\)/,
    endCaptures: {
        "0" => {
            name: "punctuation.section.parameters.end.bracket.round"
        }
    },
    name: "meta.function.definition.parameters.operator-overload",
    patterns: [
        {
            include: "#probably_a_parameter"
        },
        {
            include: "#function-innards-c"
        }
    ]
}

# 
# Access member . .* -> ->* 
#
    before_the_access_operator_1_group = newGroup(variable_name_without_bounds).or(lookBehindFor(/\]|\)/)).maybe(@spaces)
    member_operator_2_groups = newGroup(/\./.or(/\.\*/)).or(newGroup(/->/.or(/->\*/))).maybe(@spaces)
        subsequent_object_with_operator = variable_name_without_bounds.maybe(@spaces).then(/\./.or(/->/)).maybe(@spaces)
    subsequent_members_1_group = newGroup(zeroOrMoreOf(subsequent_object_with_operator))
    # try to avoid matching types to help with this not matching during lambda functions
    final_memeber_1_group = @word_boundary.lookAheadToAvoid(@cpp_tokens.that(:isType)).then(newGroup(variable_name_without_bounds)).then(@word_boundary).lookAheadToAvoid(/\(/)
member_pattern_5_groups = before_the_access_operator_1_group.then(member_operator_2_groups).then(subsequent_members_1_group).then(final_memeber_1_group)
access_member_tagger = {
    name: "variable.object.access",
    match: -member_pattern_5_groups,
    captures: {
        "1" => {
            name: "variable.object"
        },
        "2" => {
            name: "punctuation.separator.dot-access"
        },
        "3" => {
            name: "punctuation.separator.pointer-access"
        },
        "4" => {
            patterns: [
                {
                    match: -/\./,
                    name: "punctuation.separator.dot-access"
                },
                {
                    match: -/->/,
                    name: "punctuation.separator.pointer-access"
                },
                {
                    match: -variable_name_without_bounds,
                    name: "variable.object"
                },
                {
                    match: -/.+/,
                    name: "everything.else",
                }
            ]
        },
        "5" => {
            name: "variable.other.member"
        }
    }
}

# 
# Functions
# 
        cant_be_a_function_name = @cpp_tokens.that(:isWord,  not(:isPreprocessorDirective))
    avoid_keywords = lookBehindToAvoid(@standard_character).lookAheadToAvoid(maybe(@spaces).then(cant_be_a_function_name).maybe(@spaces).then(/\(/))
    look_ahead_for_function_name = lookAheadFor(variable_name_without_bounds.maybe(@spaces).then(/\(/))
function_definition_pattern = avoid_keywords.then(look_ahead_for_function_name)
function_call_pattern_4_groups = avoid_keywords.then(preceding_scopes_1_group).then(newGroup(variable_name_without_bounds)).maybe(@spaces).maybe(newGroup(template_call_match)).then(newGroup(/\(/))
# a full match example of function call would be: aNameSpace::subClass<TemplateArg>FunctionName<5>(
function_call_tagger = {
    begin: -function_call_pattern_4_groups,
    beginCaptures: {
        "1" => {
            patterns: [
                {
                    include: "#scope_resolution"
                }
            ]
        },
        "2" => {
            name: "entity.name.function.call"
        },
        "3" => {
            patterns: [
                {
                    include: "#template-call-innards"
                }
            ]
        },
        "4" => {
            name: "punctuation.section.arguments.begin.bracket.round"
        },
    },
    end: "\\)",
    endCaptures: {
        "0" => {
            name: "punctuation.section.arguments.end.bracket.round"
        }
    },
    patterns: [
        {
            include: "#function-call-innards-c"
        }
    ]
}

# 
# Namespace
# 
using_namespace_pattern_4_groups = /\b(using)\s+(namespace)\s+/.maybe(preceding_scopes_1_group).then(newGroup(variable_name)).lookAheadFor(/;|\n/)
using_namespace_tagger = {
    comment: "https://en.cppreference.com/w/cpp/language/namespace",
    begin: -using_namespace_pattern_4_groups,
    beginCaptures: {
        "1" => {
            name: "keyword.other.using.directive"
        },
        "2" => {
            name: "keyword.other.namespace.directive"
        },
        "3" => {
            patterns: [
                {
                    include: "#scope_resolution",
                },
            ]
        },
        "4" => {
            name: "entity.name.type.namespace"
        },
    },
    end: ";",
    endCaptures: {
        "0" => {
            name: "punctuation.terminator.statement"
        }
    },
    name: "meta.using-namespace-declaration"
}
# https://en.cppreference.com/w/cpp/language/namespace#Using-directives
namespace_pattern_2_groups = lookBehindToAvoid(@standard_character).then(newGroup(/namespace/)).maybe(@spaces).then(
    newGroup(zeroOrMoreOf(one_scope_resolution).then(variable_name_without_bounds)).or(
        lookAheadFor(/{/)
    )
)
namespace_definition_tagger = {
    begin: -namespace_pattern_2_groups,
    beginCaptures: {
        "1" => {
            name: "keyword.other.namespace.definition"
        },
        "2" => {
            patterns: [
                {
                    match: variable_name,
                    name: "entity.name.type",
                },
                {
                    match: -/::/,
                    name: "punctuation.separator.namespace.access"
                }
            ]
        }
    },
    end: "(?<=\\})|(?=(;|,|\\(|\\)|>|\\[|\\]|=))",
    name: "meta.namespace-block",
    patterns: [
        {
            begin: "\\{",
            beginCaptures: {
                "0" => {
                    name: "punctuation.definition.scope"
                }
            },
            end: "\\}",
            endCaptures: {
                "0" => {
                    name: "punctuation.definition.scope"
                }
            },
            patterns: [
                {
                    include: "#special_block"
                },
                {
                    include: "#constructor"
                },
                {
                    include: "$base"
                }
            ]
        },
        {
            include: "$base"
        }
    ]
}

# 
# preprocessor
#
    # not sure if this pattern is actually accurate (it was the one provided by atom/c.tmLanguage)
    preprocessor_name_no_bounds = /[a-zA-Z_$][\w$]*/
preprocessor_function_name = preprocessor_name_no_bounds.lookAheadFor(maybe(@spaces).then(/\(/))

# 
# Support
# 
support_type_pattern = @cpp_support.that(:belongsToIostream)
support_type_function_tokenizer = {
    match: variableBounds[newGroup(support_type_pattern)],
    name: "support.variable.iostream.$1",
}

cpp_grammar.data[:patterns] = [
    {
        include: "#special_block"
    },
    {
        match: /##/.then(variable_name_without_bounds).lookAheadToAvoid(@standard_character),
        name: "variable.other.macro.argument"
    },
    {
        include: "#strings"
    },
    {
        match: -functional_specifiers_pre_parameters,
        name: "storage.modifier.specificer.functional.pre-parameters.$1"
    },
    {
        match: -qualifiers_and_specifiers_post_parameters,
        name: "storage.modifier.specifier.functional.post-parameters.$1"
    },
    {
        match: -storage_specifiers,
        name: "storage.modifier.specifier.$1"
    },
    {
        match: -access_control_keywords,
        name: "storage.type.modifier.access.control.$1"
    },
    {
        match: -exception_keywords,
        name: "keyword.control.exception.$1"
    },
    {
        match: -other_keywords,
        name: "keyword.other.$1"
    },
    {
        match: -memory_operators,
        name: "keyword.operator.memory",
        captures: {
            "0" => {
                patterns: [
                    {
                        match: -/delete(\[\])/,
                        name: "keyword.operator.memory.delete.array",
                        captures: {
                            "1" => {
                                name: "keyword.operator.memory.delete.array.bracket",
                            }
                        }
                    },
                    {
                        match: -/delete/,
                        name: "keyword.operator.memory.delete"
                    },
                    {
                        match: -/new/,
                        name: "keyword.operator.memory.new"
                    },
                ]
            }
        }
    },
    {
        match: -/\bthis\b/,
        name: "variable.language.this"
    },
    {
        include: "#constants"
    },
    {
        include: "#template_definition"
    },
    {
        match: -/\btemplate\b\s*/,
        name: "storage.type.template"
    },
    {
        match: -/\b(const_cast|dynamic_cast|reinterpret_cast|static_cast)\b\s*/,
        name: "keyword.operator.cast"
    },
    {
        include: "#scope_resolution"
    },
    {
        match: -/\b(decltype|wchar_t|char16_t|char32_t)\b/,
        name: "storage.type"
    },
    {
        match: -/\b(constexpr|export|mutable|typename|thread_local)\b/,
        name: "storage.modifier"
    },
    {
        begin: "(?x)\n(?:\n  ^ |                  # beginning of line\n  (?:(?<!else|new|=))  # or word + space before name\n)\n((?:[A-Za-z_][A-Za-z0-9_]*::)*+~[A-Za-z_][A-Za-z0-9_]*) # actual name\n\\s*(\\()              # opening bracket",
        beginCaptures: {
            "1" => {
                name: "entity.name.function.destructor"
            },
            "2" => {
                name: "punctuation.definition.parameters.begin.destructor"
            }
        },
        end: -/\)/,
        endCaptures: {
            "0" => {
                name: "punctuation.definition.parameters.end.destructor"
            }
        },
        name: "meta.function.destructor",
        patterns: [
            {
                include: "$base"
            }
        ]
    },
    {
        begin: "(?x)\n(?:\n  ^ |                  # beginning of line\n  (?:(?<!else|new|=))  # or word + space before name\n)\n((?:[A-Za-z_][A-Za-z0-9_]*::)*+~[A-Za-z_][A-Za-z0-9_]*) # actual name\n\\s*(\\()              # opening bracket",
        beginCaptures: {
            "1" => {
                name: "entity.name.function"
            },
            "2" => {
                name: "punctuation.definition.parameters.begin"
            }
        },
        end: -/\)/,
        endCaptures: {
            "0" => {
                name: "punctuation.definition.parameters.end"
            }
        },
        name: "meta.function.destructor.prototype",
        patterns: [
            {
                include: "$base"
            }
        ]
    },
    # 
    # C patterns
    # 
    {
        include: "#preprocessor-rule-enabled"
    },
    {
        include: "#preprocessor-rule-disabled"
    },
    {
        include: "#preprocessor-rule-conditional"
    },
    {
        include: "#comments-c"
    },
    {
        match: "\\b(break|case|continue|default|do|else|for|goto|if|_Pragma|return|switch|while)\\b",
        name: "keyword.control.$1"
    },
    {
        include: "#storage_types-c"
    },
    {
        match: "\\b(const|extern|register|restrict|static|volatile|inline)\\b",
        name: "storage.modifier"
    },
    {
        include: "#operators"
    },
    {
        include: "#operator_overload"
    },
    {
        include: "#numbers-c"
    },
    {
        include: "#strings-c"
    },
    {
        begin: "(?x)\n^\\s* ((\\#)\\s*define) \\s+\t# define\n((?<id>#{-preprocessor_name_no_bounds}))\t  # macro name\n(?:\n  (\\()\n\t(\n\t  \\s* \\g<id> \\s*\t\t # first argument\n\t  ((,) \\s* \\g<id> \\s*)*  # additional arguments\n\t  (?:\\.\\.\\.)?\t\t\t# varargs ellipsis?\n\t)\n  (\\))\n)?",
        beginCaptures: {
            "1" => {
                name: "keyword.control.directive.define"
            },
            "2" => {
                name: "punctuation.definition.directive"
            },
            "3" => {
                name: "entity.name.function.preprocessor"
            },
            "5" => {
                name: "punctuation.definition.parameters.begin"
            },
            "6" => {
                name: "variable.parameter.preprocessor"
            },
            "8" => {
                name: "punctuation.separator.parameters"
            },
            "9" => {
                name: "punctuation.definition.parameters.end"
            }
        },
        end: "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)",
        name: "meta.preprocessor.macro",
        patterns: [
            {
                include: "#preprocessor-rule-define-line-contents"
            }
        ]
    },
    {
        begin: "^\\s*((#)\\s*(error|warning))\\b\\s*",
        beginCaptures: {
            "1" => {
                name: "keyword.control.directive.diagnostic.$3"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?<!\\\\)(?=\\n)",
        name: "meta.preprocessor.diagnostic",
        patterns: [
            {
                begin: "\"",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    }
                },
                end: "\"|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.double",
                patterns: [
                    {
                        include: "#line_continuation_character"
                    }
                ]
            },
            {
                begin: "'",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    }
                },
                end: "'|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.single",
                patterns: [
                    {
                        include: "#line_continuation_character"
                    }
                ]
            },
            {
                begin: "[^'\"]",
                end: "(?<!\\\\)(?=\\s*\\n)",
                name: "string.unquoted.single",
                patterns: [
                    {
                        include: "#line_continuation_character"
                    },
                    {
                        include: "#comments-c"
                    }
                ]
            }
        ]
    },
    {
        begin: "^\\s*((#)\\s*(include(?:_next)?|import))\\b\\s*",
        beginCaptures: {
            "1" => {
                name: "keyword.control.directive.$3"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)",
        name: "meta.preprocessor.include",
        patterns: [
            {
                include: "#line_continuation_character"
            },
            {
                begin: "\"",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    }
                },
                end: "\"",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.double.include"
            },
            {
                begin: "<",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    }
                },
                end: ">",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.other.lt-gt.include"
            }
        ]
    },
    {
        include: "#pragma-mark"
    },
    {
        begin: "^\\s*((#)\\s*line)\\b",
        beginCaptures: {
            "1" => {
                name: "keyword.control.directive.line"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)",
        name: "meta.preprocessor",
        patterns: [
            {
                include: "#strings-c"
            },
            {
                include: "#numbers-c"
            },
            {
                include: "#line_continuation_character"
            }
        ]
    },
    {
        begin: "^\\s*(?:((#)\\s*undef))\\b",
        beginCaptures: {
            "1" => {
                name: "keyword.control.directive.undef"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)",
        name: "meta.preprocessor",
        patterns: [
            {
                match: -preprocessor_name_no_bounds,
                name: "entity.name.function.preprocessor"
            },
            {
                include: "#line_continuation_character"
            }
        ]
    },
    {
        begin: "^\\s*(?:((#)\\s*pragma))\\b",
        beginCaptures: {
            "1" => {
                name: "keyword.control.directive.pragma"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)",
        name: "meta.preprocessor.pragma",
        patterns: [
            {
                include: "#strings-c"
            },
            {
                match: "[a-zA-Z_$][\\w\\-$]*",
                name: "entity.other.attribute-name.pragma.preprocessor"
            },
            {
                include: "#numbers-c"
            },
            {
                include: "#line_continuation_character"
            }
        ]
    },
    {
        match: "\\b(u_char|u_short|u_int|u_long|ushort|uint|u_quad_t|quad_t|qaddr_t|caddr_t|daddr_t|div_t|dev_t|fixpt_t|blkcnt_t|blksize_t|gid_t|in_addr_t|in_port_t|ino_t|key_t|mode_t|nlink_t|id_t|pid_t|off_t|segsz_t|swblk_t|uid_t|id_t|clock_t|size_t|ssize_t|time_t|useconds_t|suseconds_t)\\b",
        name: "support.type.sys-types"
    },
    {
        match: "\\b(pthread_attr_t|pthread_cond_t|pthread_condattr_t|pthread_mutex_t|pthread_mutexattr_t|pthread_once_t|pthread_rwlock_t|pthread_rwlockattr_t|pthread_t|pthread_key_t)\\b",
        name: "support.type.pthread"
    },
    {
        match: "(?x) \\b\n(int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|int_least8_t\n|int_least16_t|int_least32_t|int_least64_t|uint_least8_t|uint_least16_t|uint_least32_t\n|uint_least64_t|int_fast8_t|int_fast16_t|int_fast32_t|int_fast64_t|uint_fast8_t\n|uint_fast16_t|uint_fast32_t|uint_fast64_t|intptr_t|uintptr_t|intmax_t|intmax_t\n|uintmax_t|uintmax_t)\n\\b",
        name: "support.type.stdint"
    },
    {
        match: -posix_reserved_types,
        name: "support.type.posix-reserved"
    },
    {
        include: "#block-c"
    },
    {
        include: "#parens-c"
    },
    {
        begin: -function_definition_pattern,
        end: -lookBehindFor(/\)/), # old pattern: "(?<=\\))(?!\\w)",
        name: "meta.function.definition",
        patterns: [
            {
                include: "#function-innards-c"
            }
        ]
    },
    {
        include: "#line_continuation_character"
    },
    {
        name: "meta.bracket.square.access",
        begin: "([a-zA-Z_][a-zA-Z_0-9]*|(?<=[\\]\\)]))?(\\[)(?!\\])",
        beginCaptures: {
            "1" => {
                name: "variable.object"
            },
            "2" => {
                name: "punctuation.definition.begin.bracket.square"
            }
        },
        end: "\\]",
        endCaptures: {
            "0" => {
                name: "punctuation.definition.end.bracket.square"
            }
        },
        patterns: [
            {
                include: "#function-call-innards-c"
            }
        ]
    },
    {
        name: "storage.modifier.array.bracket.square",
        match: -/#{lookBehindToAvoid(/delete/)}\\[\\s*\\]/
    },
    {
        match: ";",
        name: "punctuation.terminator.statement"
    },
    {
        match: ",",
        name: "punctuation.separator.delimiter"
    }
]
cpp_grammar.data[:repository] = {
    "template-call-innards" => template_call_innards_tagger,
    "constants" => constants.to_h,
    "scope_resolution" => scope_resolution_tagger,
    "template_definition" => template_definition_tagger,
    "template_definition_argument" => template_definition_argument_tagger,
    "angle_brackets" => {
        begin: "<",
        end: ">",
        name: "meta.angle-brackets",
        patterns: [
            {
                include: "#angle_brackets"
            },
            {
                include: "$base"
            }
        ]
    },
    "block" => {
        begin: "\\{",
        beginCaptures: {
            "0" => {
                name: "punctuation.section.block.begin.bracket.curly"
            }
        },
        end: "\\}",
        endCaptures: {
            "0" => {
                name: "punctuation.section.block.end.bracket.curly"
            }
        },
        name: "meta.block",
        patterns: [
            {
                captures: {
                    "1" => {
                        name: "support.function.any-method"
                    },
                    "2" => {
                        name: "punctuation.definition.parameters"
                    }
                },
                match: "(?x)\n(\n  (?!while|for|do|if|else|switch|catch|return)\n  (?:\\b[A-Za-z_][A-Za-z0-9_]*+\\b|::)*+ # actual name\n)\n\\s*(\\() # opening bracket",
                name: "meta.function-call"
            },
            {
                include: "$base"
            }
        ]
    },
    "constructor" => {
        patterns: [
            {
                begin: "(?x)\n(?:^\\s*)  # beginning of line\n((?!while|for|do|if|else|switch|catch)[A-Za-z_][A-Za-z0-9_:]*) # actual name\n\\s*(\\()  # opening bracket",
                beginCaptures: {
                    "1" => {
                        name: "entity.name.function.constructor"
                    },
                    "2" => {
                        name: "punctuation.definition.parameters.begin.constructor"
                    }
                },
                end: "\\)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.parameters.end.constructor"
                    }
                },
                name: "meta.function.constructor",
                patterns: [
                    {
                        include: "#probably_a_parameter"
                    },
                    {
                        include: "#function-innards-c"
                    }
                ]
            },
            {
                begin: "(?x)\n(:)\n(\n  (?=\n    \\s*[A-Za-z_][A-Za-z0-9_:]* # actual name\n    \\s* (\\() # opening bracket\n  )\n)",
                beginCaptures: {
                    "1" => {
                        name: "punctuation.definition.initializer-list.parameters"
                    }
                },
                end: "(?=\\{)",
                name: "meta.function.constructor.initializer-list",
                patterns: [
                    {
                        include: "$base"
                    }
                ]
            }
        ]
    },
    "special_block" => {
        patterns: [
            using_namespace_tagger,
            namespace_definition_tagger,
            {
                begin: "\\b(?:(class)|(struct))\\b\\s*([_A-Za-z][_A-Za-z0-9]*\\b)?+(\\s*:\\s*(public|protected|private)\\s*([_A-Za-z][_A-Za-z0-9]*\\b)((\\s*,\\s*(public|protected|private)\\s*[_A-Za-z][_A-Za-z0-9]*\\b)*))?",
                beginCaptures: {
                    "1" => {
                        name: "storage.type.class"
                    },
                    "2" => {
                        name: "storage.type.struct"
                    },
                    "3" => {
                        name: "entity.name.type"
                    },
                    "5" => {
                        name: "storage.type.modifier.access"
                    },
                    "6" => {
                        name: "entity.name.type.inherited"
                    },
                    "7" => {
                        patterns: [
                            {
                                match: "(public|protected|private)",
                                name: "storage.type.modifier.access"
                            },
                            {
                                match: "[_A-Za-z][_A-Za-z0-9]*",
                                name: "entity.name.type.inherited"
                            }
                        ]
                    }
                },
                end: "(?<=\\})|(;)|(?=(\\(|\\)|>|\\[|\\]|=))",
                endCaptures: {
                    "1" => {
                        name: "punctuation.terminator.statement",
                    },
                },
                name: "meta.class-struct-block",
                patterns: [
                    {
                        include: "#angle_brackets"
                    },
                    {
                        begin: "\\{",
                        beginCaptures: {
                            "0" => {
                                name: "punctuation.section.block.begin.bracket.curly"
                            }
                        },
                        end: "(\\})(\\s*\\n)?",
                        endCaptures: {
                            "1" => {
                                name: "punctuation.section.block.end.bracket.curly"
                            },
                            "2" => {
                                name: "invalid.illegal.you-forgot-semicolon"
                            }
                        },
                        patterns: [
                            {
                                include: "#special_block"
                            },
                            {
                                include: "#constructor"
                            },
                            {
                                include: "$base"
                            }
                        ]
                    },
                    {
                        include: "$base"
                    }
                ]
            },
            {
                begin: "\\b(extern)(?=\\s*\")",
                beginCaptures: {
                    "1" => {
                        name: "storage.modifier"
                    }
                },
                end: "(?<=\\})|(?=\\w)|(?=\\s*#\\s*endif\\b)",
                name: "meta.extern-block",
                patterns: [
                    {
                        begin: "\\{",
                        beginCaptures: {
                            "0" => {
                                name: "punctuation.section.block.begin.bracket.curly"
                            }
                        },
                        end: "\\}|(?=\\s*#\\s*endif\\b)",
                        endCaptures: {
                            "0" => {
                                name: "punctuation.section.block.end.bracket.curly"
                            }
                        },
                        patterns: [
                            {
                                include: "#special_block"
                            },
                            {
                                include: "$base"
                            }
                        ]
                    },
                    {
                        include: "$base"
                    }
                ]
            }
        ]
    },
    "strings" => {
        patterns: [
            {
                begin: "(u|u8|U|L)?\"",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    },
                    "1" => {
                        name: "meta.encoding"
                    }
                },
                end: "\"",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.double",
                patterns: [
                    {
                        match: "\\\\u\\h{4}|\\\\U\\h{8}",
                        name: "constant.character.escape"
                    },
                    {
                        match: "\\\\['\"?\\\\abfnrtv]",
                        name: "constant.character.escape"
                    },
                    {
                        match: "\\\\[0-7]{1,3}",
                        name: "constant.character.escape"
                    },
                    {
                        match: "\\\\x\\h+",
                        name: "constant.character.escape"
                    },
                    {
                        include: "#string_placeholder-c"
                    }
                ]
            },
            {
                begin: "(u|u8|U|L)?R\"(?:([^ ()\\\\\\t]{0,16})|([^ ()\\\\\\t]*))\\(",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    },
                    "1" => {
                        name: "meta.encoding"
                    },
                    "3" => {
                        name: "invalid.illegal.delimiter-too-long"
                    }
                },
                end: "\\)\\2(\\3)\"",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    },
                    "1" => {
                        name: "invalid.illegal.delimiter-too-long"
                    }
                },
                name: "string.quoted.double.raw"
            }
        ]
    },
    "probably_a_parameter" => probably_a_parameter_tagger,
    "operator_overload" => operator_overload_tagger,
    "access-method" => {
        name: "meta.function-call.member",
        begin: "([a-zA-Z_][a-zA-Z_0-9]*|(?<=[\\]\\)]))\\s*(?:(\\.)|(->))((?:(?:[a-zA-Z_][a-zA-Z_0-9]*)\\s*(?:(?:\\.)|(?:->)))*)\\s*([a-zA-Z_][a-zA-Z_0-9]*)(\\()",
        beginCaptures: {
            "1" => {
                name: "variable.object"
            },
            "2" => {
                name: "punctuation.separator.dot-access"
            },
            "3" => {
                name: "punctuation.separator.pointer-access"
            },
            "4" => {
                patterns: [
                    {
                        match: "\\.",
                        name: "punctuation.separator.dot-access"
                    },
                    {
                        match: "->",
                        name: "punctuation.separator.pointer-access"
                    },
                    {
                        match: "[a-zA-Z_][a-zA-Z_0-9]*",
                        name: "variable.object"
                    },
                    {
                        name: "everything.else",
                        match: ".+"
                    }
                ]
            },
            "5" => {
                name: "entity.name.function.member"
            },
            "6" => {
                name: "punctuation.section.arguments.begin.bracket.round.function.member"
            }
        },
        end: "\\)",
        endCaptures: {
            "0" => {
                name: "punctuation.section.arguments.end.bracket.round.function.member"
            }
        },
        patterns: [
            {
                include: "#function-call-innards-c"
            }
        ]
    },
    "access-member" => access_member_tagger,
    "block-c" => {
        patterns: [
            {
                begin: "{",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.section.block.begin.bracket.curly"
                    }
                },
                end: "}|(?=\\s*#\\s*(?:elif|else|endif)\\b)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.block.end.bracket.curly"
                    }
                },
                name: "meta.block",
                patterns: [
                    {
                        include: "#block_innards-c"
                    }
                ]
            }
        ]
    },
    "block_innards-c" => {
        patterns: [
            {
                include: "#preprocessor-rule-enabled-block"
            },
            {
                include: "#preprocessor-rule-disabled-block"
            },
            {
                include: "#preprocessor-rule-conditional-block"
            },
            {
                include: "#access-method"
            },
            {
                include: "#access-member"
            },
            {
                include: "#c_function_call"
            },
            {
                name: "meta.initialization",
                begin: "(?x)\n(?:\n  (?:\n\t(?=\\s)(?<!else|new|return)\n\t(?<=\\w) \\s+(and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas)  # or word + space before name\n  )\n)\n(\n  (?:[A-Za-z_][A-Za-z0-9_]*+ | :: )++   # actual name\n  |\n  (?:(?<=operator) (?:[-*&<>=+!]+ | \\(\\) | \\[\\]))\n)\n\\s*(\\() # opening bracket",
                beginCaptures: {
                    "1" => {
                        name: "variable.other"
                    },
                    "2" => {
                        name: "punctuation.section.parens.begin.bracket.round.initialization"
                    }
                },
                end: "\\)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.parens.end.bracket.round.initialization"
                    }
                },
                patterns: [
                    {
                        include: "#function-call-innards-c"
                    }
                ]
            },
            {
                begin: "{",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.section.block.begin.bracket.curly"
                    }
                },
                end: "}|(?=\\s*#\\s*(?:elif|else|endif)\\b)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.block.end.bracket.curly"
                    }
                },
                patterns: [
                    {
                        include: "#block_innards-c"
                    }
                ]
            },
            {
                include: "#parens-block-c"
            },
            {
                include: "$base"
            }
        ]
    },
    "c_function_call" => {
        begin: "(?x)\n(?!(?:while|for|do|if|else|switch|catch|return|typeid|alignof|alignas|sizeof|and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas)\\s*\\()\n(?=\n(?:[A-Za-z_][A-Za-z0-9_]*+|::)++\\s*#{-maybe(template_call_match)}\\(  # actual name\n|\n(?:(?<=operator)(?:[-*&<>=+!]+|\\(\\)|\\[\\]))\\s*\\(\n)",
        end: "(?<=\\))(?!\\w)",
        name: "meta.function-call",
        patterns: [
            {
                include: "#function-call-innards-c"
            }
        ]
    },
    "comments-c" => {
        patterns: [
            {
                captures: {
                    "1" => {
                        name: "meta.toc-list.banner.block"
                    }
                },
                match: "^/\\* =(\\s*.*?)\\s*= \\*/$\\n?",
                name: "comment.block"
            },
            {
                begin: "/\\*",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.comment.begin"
                    }
                },
                end: "\\*/",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.comment.end"
                    }
                },
                name: "comment.block"
            },
            {
                match: "\\*/.*\\n",
                name: "invalid.illegal.stray-comment-end"
            },
            {
                captures: {
                    "1" => {
                        name: "meta.toc-list.banner.line"
                    }
                },
                match: "^// =(\\s*.*?)\\s*=\\s*$\\n?",
                name: "comment.line.banner"
            },
            {
                begin: "(^[ \\t]+)?(?=//)",
                beginCaptures: {
                    "1" => {
                        name: "punctuation.whitespace.comment.leading"
                    }
                },
                end: "(?!\\G)",
                patterns: [
                    {
                        begin: "//",
                        beginCaptures: {
                            "0" => {
                                name: "punctuation.definition.comment"
                            }
                        },
                        end: "(?=\\n)",
                        name: "comment.line.double-slash",
                        patterns: [
                            {
                                include: "#line_continuation_character"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "disabled" => {
        begin: "^\\s*#\\s*if(n?def)?\\b.*$",
        end: "^\\s*#\\s*endif\\b",
        patterns: [
            {
                include: "#disabled"
            },
            {
                include: "#pragma-mark"
            }
        ]
    },
    "line_continuation_character" => {
        patterns: [
            {
                match: "(\\\\)\\n",
                captures: {
                    "1" => {
                        name: "constant.character.escape.line-continuation"
                    }
                }
            }
        ]
    },
    "numbers-c" => {
        patterns: [
            {
                # TODO: this pattern needs improving 
                match: -numeric_pattern,
                name: "constant.numeric",
                captures: {
                    "0" => {
                        patterns: [
                            {
                                match: octal_pattern,
                                name: "keyword.other.unit.octal",
                            },
                            {
                                match: hex_pattern,
                                name: "keyword.other.unit.hexadecimal",
                            },
                            {
                                match: binary_pattern,
                                name: "keyword.other.unit.binary",
                            },
                            {
                                match: non_hex_non_octal_units,
                                name: "keyword.other.unit",
                            },
                        ]
                    },
                },
            }
        ]
    },
    "parens-c" => {
        name: "punctuation.section.parens-c\b",
        begin: "\\(",
        beginCaptures: {
            "0" => {
                name: "punctuation.section.parens.begin.bracket.round"
            }
        },
        end: "\\)",
        endCaptures: {
            "0" => {
                name: "punctuation.section.parens.end.bracket.round"
            }
        },
        patterns: [
            {
                include: "$base"
            }
        ]
    },
    "parens-block-c" => {
        name: "meta.block.parens",
        begin: "\\(",
        beginCaptures: {
            "0" => {
                name: "punctuation.section.parens.begin.bracket.round"
            }
        },
        end: "\\)",
        endCaptures: {
            "0" => {
                name: "punctuation.section.parens.end.bracket.round"
            }
        },
        patterns: [
            {
                include: "#block_innards-c"
            },
            {
                match: -lookBehindToAvoid(/:/).then(/:/).lookAheadToAvoid(/:/),
                name: "punctuation.range-based"
            }
        ]
    },
    "pragma-mark" => {
        captures: {
            "1" => {
                name: "meta.preprocessor.pragma"
            },
            "2" => {
                name: "keyword.control.directive.pragma.pragma-mark"
            },
            "3" => {
                name: "punctuation.definition.directive"
            },
            "4" => {
                name: "entity.name.tag.pragma-mark"
            }
        },
        match: "^\\s*(((#)\\s*pragma\\s+mark)\\s+(.*))",
        name: "meta.section"
    },
    "operators" => {
        patterns: [
            {
                match: variableBounds[newGroup(any_normal_word_operator_keyword)],
                name: "keyword.operator.$1"
            },
            {
                match: "--",
                name: "keyword.operator.decrement"
            },
            {
                match: "\\+\\+",
                name: "keyword.operator.increment"
            },
            {
                match: "%=|\\+=|-=|\\*=|(?<!\\()/=",
                name: "keyword.operator.assignment.compound"
            },
            {
                match: "&=|\\^=|<<=|>>=|\\|=",
                name: "keyword.operator.assignment.compound.bitwise"
            },
            {
                match: "<<|>>",
                name: "keyword.operator.bitwise.shift"
            },
            {
                match: "!=|<=|>=|==|<|>",
                name: "keyword.operator.comparison"
            },
            {
                match: "&&|!|\\|\\|",
                name: "keyword.operator.logical"
            },
            {
                match: "&|\\||\\^|~",
                name: "keyword.operator"
            },
            {
                match: "=",
                name: "keyword.operator.assignment"
            },
            {
                match: "%|\\*|/|-|\\+",
                name: "keyword.operator"
            },
            {
                begin: "\\?",
                beginCaptures: {
                    "0" => {
                        name: "keyword.operator.ternary"
                    }
                },
                end: ":",
                applyEndPatternLast: true,
                endCaptures: {
                    "0" => {
                        name: "keyword.operator.ternary"
                    }
                },
                patterns: [
                    {
                        include: "#access-method"
                    },
                    {
                        include: "#access-member"
                    },
                    {
                        include: "#c_function_call"
                    },
                    {
                        include: "$base"
                    }
                ]
            }
        ]
    },
    "strings-c" => {
        patterns: [
            {
                begin: "\"",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    }
                },
                end: "\"",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.double",
                patterns: [
                    {
                        include: "#string_escaped_char-c"
                    },
                    {
                        include: "#string_placeholder-c"
                    },
                    {
                        include: "#line_continuation_character"
                    }
                ]
            },
            {
                begin: lookBehindToAvoid(/[\da-fA-F]/).then(/'/),
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    }
                },
                end: "'",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.single",
                patterns: [
                    {
                        include: "#string_escaped_char-c"
                    },
                    {
                        include: "#line_continuation_character"
                    }
                ]
            }
        ]
    },
    "string_escaped_char-c" => {
        patterns: [
            {
                match: "(?x)\\\\ (\n\\\\\t\t\t |\n[abefnprtv'\"?]   |\n[0-3]\\d{,2}\t |\n[4-7]\\d?\t\t|\nx[a-fA-F0-9]{,2} |\nu[a-fA-F0-9]{,4} |\nU[a-fA-F0-9]{,8} )",
                name: "constant.character.escape"
            },
            {
                match: "\\\\.",
                name: "invalid.illegal.1.unknown-escape"
            }
        ]
    },
    "string_placeholder-c" => {
        patterns: [
            {
                match: "(?x) %\n(\\d+\\$)?\t\t\t\t\t\t   # field (argument #)\n[#0\\- +']*\t\t\t\t\t\t  # flags\n[,;:_]?\t\t\t\t\t\t\t  # separator character (AltiVec)\n((-?\\d+)|\\*(-?\\d+\\$)?)?\t\t  # minimum field width\n(\\.((-?\\d+)|\\*(-?\\d+\\$)?)?)?\t# precision\n(hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)? # length modifier\n[diouxXDOUeEfFgGaACcSspn%]\t\t   # conversion type",
                name: "constant.other.placeholder"
            },
            # I don't think these are actual escapes, and they incorrectly mark valid strings
            # It might be related to printf and format from C (which is low priority for C++)
            # {
            #     match: "(%)(?!\"\\s*(PRI|SCN))",
            #     captures: {
            #         "1" => {
            #             name: "constant.other.placeholder"
            #         }
            #     }
            # }
        ]
    },
    "storage_types-c" => {
        patterns: [
            {
                match: -non_primitive_types.or(/_Bool|_Complex|_Imaginary/),
                name: "storage.type.language",
            },
            {
                match: -primitive_types,
                name: "storage.type.language.primitive",
            },
            {
                match: -/\b(asm|__asm__|enum|struct|union)\b/,
                name: "storage.type.$1"
            },
        ]
    },
    "vararg_ellipses-c" => {
        match: "(?<!\\.)\\.\\.\\.(?!\\.)",
        name: "punctuation.vararg-ellipses"
    },
    "preprocessor-rule-conditional" => {
        patterns: [
            {
                begin: "^\\s*((#)\\s*if(?:n?def)?\\b)",
                beginCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                end: "^\\s*((#)\\s*endif\\b)",
                endCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                patterns: [
                    {
                        begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                        end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                        name: "meta.preprocessor",
                        patterns: [
                            {
                                include: "#preprocessor-rule-conditional-line"
                            }
                        ]
                    },
                    {
                        include: "#preprocessor-rule-enabled-elif"
                    },
                    {
                        include: "#preprocessor-rule-enabled-else"
                    },
                    {
                        include: "#preprocessor-rule-disabled-elif"
                    },
                    {
                        begin: "^\\s*((#)\\s*elif\\b)",
                        beginCaptures: {
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                        name: "meta.preprocessor",
                        patterns: [
                            {
                                include: "#preprocessor-rule-conditional-line"
                            }
                        ]
                    },
                    {
                        include: "$base"
                    }
                ]
            },
            {
                match: "^\\s*#\\s*(else|elif|endif)\\b",
                captures: {
                    "0" => {
                        name: "invalid.illegal.stray-$1"
                    }
                }
            }
        ]
    },
    "preprocessor-rule-conditional-block" => {
        patterns: [
            {
                begin: "^\\s*((#)\\s*if(?:n?def)?\\b)",
                beginCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                end: "^\\s*((#)\\s*endif\\b)",
                endCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                patterns: [
                    {
                        begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                        end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                        name: "meta.preprocessor",
                        patterns: [
                            {
                                include: "#preprocessor-rule-conditional-line"
                            }
                        ]
                    },
                    {
                        include: "#preprocessor-rule-enabled-elif-block"
                    },
                    {
                        include: "#preprocessor-rule-enabled-else-block"
                    },
                    {
                        include: "#preprocessor-rule-disabled-elif"
                    },
                    {
                        begin: "^\\s*((#)\\s*elif\\b)",
                        beginCaptures: {
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                        name: "meta.preprocessor",
                        patterns: [
                            {
                                include: "#preprocessor-rule-conditional-line"
                            }
                        ]
                    },
                    {
                        include: "#block_innards-c"
                    }
                ]
            },
            {
                match: "^\\s*#\\s*(else|elif|endif)\\b",
                captures: {
                    "0" => {
                        name: "invalid.illegal.stray-$1"
                    }
                }
            }
        ]
    },
    "preprocessor-rule-conditional-line" => {
        patterns: [
            {
                match: "(?:\\bdefined\\b\\s*$)|(?:\\bdefined\\b(?=\\s*\\(*\\s*(?:(?!defined\\b)[a-zA-Z_$][\\w$]*\\b)\\s*\\)*\\s*(?:\\n|//|/\\*|\\?|\\:|&&|\\|\\||\\\\\\s*\\n)))",
                name: "keyword.control.directive.conditional"
            },
            {
                match: "\\bdefined\\b",
                name: "invalid.illegal.macro-name"
            },
            {
                include: "#comments-c"
            },
            {
                include: "#strings-c"
            },
            {
                include: "#numbers-c"
            },
            {
                begin: "\\?",
                beginCaptures: {
                    "0" => {
                        name: "keyword.operator.ternary"
                    }
                },
                end: ":",
                endCaptures: {
                    "0" => {
                        name: "keyword.operator.ternary"
                    }
                },
                patterns: [
                    {
                        include: "#preprocessor-rule-conditional-line"
                    }
                ]
            },
            {
                include: "#operators"
            },
            {
                include: "#constants"
            },
            {
                match: -preprocessor_name_no_bounds,
                name: "entity.name.function.preprocessor"
            },
            {
                include: "#line_continuation_character"
            },
            {
                begin: "\\(",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.section.parens.begin.bracket.round"
                    }
                },
                end: "\\)|(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.parens.end.bracket.round"
                    }
                },
                patterns: [
                    {
                        include: "#preprocessor-rule-conditional-line"
                    }
                ]
            }
        ]
    },
    "preprocessor-rule-disabled" => {
        patterns: [
            {
                begin: "^\\s*((#)\\s*if\\b)(?=\\s*\\(*\\b0+\\b\\)*\\s*(?:$|//|/\\*))",
                beginCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                end: "^\\s*((#)\\s*endif\\b)",
                endCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                patterns: [
                    {
                        begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                        end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?=\\n)",
                        name: "meta.preprocessor",
                        patterns: [
                            {
                                include: "#preprocessor-rule-conditional-line"
                            }
                        ]
                    },
                    {
                        include: "#comments-c"
                    },
                    {
                        include: "#preprocessor-rule-enabled-elif"
                    },
                    {
                        include: "#preprocessor-rule-enabled-else"
                    },
                    {
                        include: "#preprocessor-rule-disabled-elif"
                    },
                    {
                        begin: "^\\s*((#)\\s*elif\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*(?:elif|else|endif)\\b))",
                        patterns: [
                            {
                                begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                                end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                                name: "meta.preprocessor",
                                patterns: [
                                    {
                                        include: "#preprocessor-rule-conditional-line"
                                    }
                                ]
                            },
                            {
                                include: "$base"
                            }
                        ]
                    },
                    {
                        begin: "\\n",
                        end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                        "contentName" => "comment.block.preprocessor.if-branch",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma-mark"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "preprocessor-rule-disabled-block" => {
        patterns: [
            {
                begin: "^\\s*((#)\\s*if\\b)(?=\\s*\\(*\\b0+\\b\\)*\\s*(?:$|//|/\\*))",
                beginCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                end: "^\\s*((#)\\s*endif\\b)",
                endCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                patterns: [
                    {
                        begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                        end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?=\\n)",
                        name: "meta.preprocessor",
                        patterns: [
                            {
                                include: "#preprocessor-rule-conditional-line"
                            }
                        ]
                    },
                    {
                        include: "#comments-c"
                    },
                    {
                        include: "#preprocessor-rule-enabled-elif-block"
                    },
                    {
                        include: "#preprocessor-rule-enabled-else-block"
                    },
                    {
                        include: "#preprocessor-rule-disabled-elif"
                    },
                    {
                        begin: "^\\s*((#)\\s*elif\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*(?:elif|else|endif)\\b))",
                        patterns: [
                            {
                                begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                                end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                                name: "meta.preprocessor",
                                patterns: [
                                    {
                                        include: "#preprocessor-rule-conditional-line"
                                    }
                                ]
                            },
                            {
                                include: "#block_innards-c"
                            }
                        ]
                    },
                    {
                        begin: "\\n",
                        end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                        "contentName" => "comment.block.preprocessor.if-branch.in-block",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma-mark"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "preprocessor-rule-disabled-elif" => {
        begin: "^\\s*((#)\\s*elif\\b)(?=\\s*\\(*\\b0+\\b\\)*\\s*(?:$|//|/\\*))",
        beginCaptures: {
            "0" => {
                name: "meta.preprocessor"
            },
            "1" => {
                name: "keyword.control.directive.conditional"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=^\\s*((#)\\s*(?:elif|else|endif)\\b))",
        patterns: [
            {
                begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                name: "meta.preprocessor",
                patterns: [
                    {
                        include: "#preprocessor-rule-conditional-line"
                    }
                ]
            },
            {
                include: "#comments-c"
            },
            {
                begin: "\\n",
                end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                "contentName" => "comment.block.preprocessor.elif-branch",
                patterns: [
                    {
                        include: "#disabled"
                    },
                    {
                        include: "#pragma-mark"
                    }
                ]
            }
        ]
    },
    "preprocessor-rule-enabled" => {
        patterns: [
            {
                begin: "^\\s*((#)\\s*if\\b)(?=\\s*\\(*\\b0*1\\b\\)*\\s*(?:$|//|/\\*))",
                beginCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    },
                    "3" => {
                        name: "constant.numeric.preprocessor"
                    }
                },
                end: "^\\s*((#)\\s*endif\\b)",
                endCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                patterns: [
                    {
                        begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                        end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?=\\n)",
                        name: "meta.preprocessor",
                        patterns: [
                            {
                                include: "#preprocessor-rule-conditional-line"
                            }
                        ]
                    },
                    {
                        include: "#comments-c"
                    },
                    {
                        begin: "^\\s*((#)\\s*else\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*endif\\b))",
                        "contentName" => "comment.block.preprocessor.else-branch",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma-mark"
                            }
                        ]
                    },
                    {
                        begin: "^\\s*((#)\\s*elif\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                        "contentName" => "comment.block.preprocessor.if-branch",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma-mark"
                            }
                        ]
                    },
                    {
                        begin: "\\n",
                        end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                        patterns: [
                            {
                                include: "$base"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "preprocessor-rule-enabled-block" => {
        patterns: [
            {
                begin: "^\\s*((#)\\s*if\\b)(?=\\s*\\(*\\b0*1\\b\\)*\\s*(?:$|//|/\\*))",
                beginCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                end: "^\\s*((#)\\s*endif\\b)",
                endCaptures: {
                    "0" => {
                        name: "meta.preprocessor"
                    },
                    "1" => {
                        name: "keyword.control.directive.conditional"
                    },
                    "2" => {
                        name: "punctuation.definition.directive"
                    }
                },
                patterns: [
                    {
                        begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                        end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?=\\n)",
                        name: "meta.preprocessor",
                        patterns: [
                            {
                                include: "#preprocessor-rule-conditional-line"
                            }
                        ]
                    },
                    {
                        include: "#comments-c"
                    },
                    {
                        begin: "^\\s*((#)\\s*else\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*endif\\b))",
                        "contentName" => "comment.block.preprocessor.else-branch.in-block",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma-mark"
                            }
                        ]
                    },
                    {
                        begin: "^\\s*((#)\\s*elif\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                        "contentName" => "comment.block.preprocessor.if-branch.in-block",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma-mark"
                            }
                        ]
                    },
                    {
                        begin: "\\n",
                        end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                        patterns: [
                            {
                                include: "#block_innards-c"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "preprocessor-rule-enabled-elif" => {
        begin: "^\\s*((#)\\s*elif\\b)(?=\\s*\\(*\\b0*1\\b\\)*\\s*(?:$|//|/\\*))",
        beginCaptures: {
            "0" => {
                name: "meta.preprocessor"
            },
            "1" => {
                name: "keyword.control.directive.conditional"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=^\\s*((#)\\s*endif\\b))",
        patterns: [
            {
                begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                name: "meta.preprocessor",
                patterns: [
                    {
                        include: "#preprocessor-rule-conditional-line"
                    }
                ]
            },
            {
                include: "#comments-c"
            },
            {
                begin: "\\n",
                end: "(?=^\\s*((#)\\s*(?:endif)\\b))",
                patterns: [
                    {
                        begin: "^\\s*((#)\\s*(else)\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*endif\\b))",
                        "contentName" => "comment.block.preprocessor.elif-branch",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma-mark"
                            }
                        ]
                    },
                    {
                        begin: "^\\s*((#)\\s*(elif)\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                        "contentName" => "comment.block.preprocessor.elif-branch",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma-mark"
                            }
                        ]
                    },
                    {
                        include: "$base"
                    }
                ]
            }
        ]
    },
    "preprocessor-rule-enabled-elif-block" => {
        begin: "^\\s*((#)\\s*elif\\b)(?=\\s*\\(*\\b0*1\\b\\)*\\s*(?:$|//|/\\*))",
        beginCaptures: {
            "0" => {
                name: "meta.preprocessor"
            },
            "1" => {
                name: "keyword.control.directive.conditional"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=^\\s*((#)\\s*endif\\b))",
        patterns: [
            {
                begin: "\\G(?=.)(?!//|/\\*(?!.*\\\\\\s*\\n))",
                end: "(?=//)|(?=/\\*(?!.*\\\\\\s*\\n))|(?<!\\\\)(?=\\n)",
                name: "meta.preprocessor",
                patterns: [
                    {
                        include: "#preprocessor-rule-conditional-line"
                    }
                ]
            },
            {
                include: "#comments-c"
            },
            {
                begin: "\\n",
                end: "(?=^\\s*((#)\\s*(?:endif)\\b))",
                patterns: [
                    {
                        begin: "^\\s*((#)\\s*(else)\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*endif\\b))",
                        "contentName" => "comment.block.preprocessor.elif-branch.in-block",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma-mark"
                            }
                        ]
                    },
                    {
                        begin: "^\\s*((#)\\s*(elif)\\b)",
                        beginCaptures: {
                            "0" => {
                                name: "meta.preprocessor"
                            },
                            "1" => {
                                name: "keyword.control.directive.conditional"
                            },
                            "2" => {
                                name: "punctuation.definition.directive"
                            }
                        },
                        end: "(?=^\\s*((#)\\s*(?:else|elif|endif)\\b))",
                        "contentName" => "comment.block.preprocessor.elif-branch",
                        patterns: [
                            {
                                include: "#disabled"
                            },
                            {
                                include: "#pragma-mark"
                            }
                        ]
                    },
                    {
                        include: "#block_innards-c"
                    }
                ]
            }
        ]
    },
    "preprocessor-rule-enabled-else" => {
        begin: "^\\s*((#)\\s*else\\b)",
        beginCaptures: {
            "0" => {
                name: "meta.preprocessor"
            },
            "1" => {
                name: "keyword.control.directive.conditional"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=^\\s*((#)\\s*endif\\b))",
        patterns: [
            {
                include: "$base"
            }
        ]
    },
    "preprocessor-rule-enabled-else-block" => {
        begin: "^\\s*((#)\\s*else\\b)",
        beginCaptures: {
            "0" => {
                name: "meta.preprocessor"
            },
            "1" => {
                name: "keyword.control.directive.conditional"
            },
            "2" => {
                name: "punctuation.definition.directive"
            }
        },
        end: "(?=^\\s*((#)\\s*endif\\b))",
        patterns: [
            {
                include: "#block_innards-c"
            }
        ]
    },
    "preprocessor-rule-define-line-contents" => {
        patterns: [
            {
                include: "#vararg_ellipses-c"
            },
            {
                match: /##?/.then(variable_name_without_bounds).lookAheadToAvoid(@standard_character),
                name: "variable.other.macro.argument"
            },
            {
                begin: "{",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.section.block.begin.bracket.curly"
                    }
                },
                end: "}|(?=\\s*#\\s*(?:elif|else|endif)\\b)|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.block.end.bracket.curly"
                    }
                },
                name: "meta.block",
                patterns: [
                    {
                        include: "#preprocessor-rule-define-line-blocks"
                    }
                ]
            },
            {
                match: "\\(",
                name: "punctuation.section.parens.begin.bracket.round"
            },
            {
                match: "\\)",
                name: "punctuation.section.parens.end.bracket.round"
            },
            {
                begin: "(?x)\n(?!(?:while|for|do|if|else|switch|catch|return|typeid|alignof|alignas|sizeof|and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas|asm|__asm__|auto|bool|_Bool|char|_Complex|double|enum|float|_Imaginary|int|long|short|signed|struct|typedef|union|unsigned|void)\\s*\\()\n(?=\n  (?:[A-Za-z_][A-Za-z0-9_]*+|::)++\\s*\\(  # actual name\n  |\n  (?:(?<=operator)(?:[-*&<>=+!]+|\\(\\)|\\[\\]))\\s*\\(\n)",
                end: "(?<=\\))(?!\\w)|(?<!\\\\)(?=\\s*\\n)",
                name: "meta.function",
                patterns: [
                    {
                        include: "#preprocessor-rule-define-line-functions"
                    }
                ]
            },
            {
                begin: "\"",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    }
                },
                end: "\"|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.double",
                patterns: [
                    {
                        include: "#string_escaped_char-c"
                    },
                    {
                        include: "#string_placeholder-c"
                    },
                    {
                        include: "#line_continuation_character"
                    }
                ]
            },
            {
                begin: "'",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.begin"
                    }
                },
                end: "'|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.definition.string.end"
                    }
                },
                name: "string.quoted.single",
                patterns: [
                    {
                        include: "#string_escaped_char-c"
                    },
                    {
                        include: "#line_continuation_character"
                    }
                ]
            },
            {
                include: "#access-method"
            },
            {
                include: "#access-member"
            },
            {
                include: "$base"
            }
        ]
    },
    "preprocessor-rule-define-line-blocks" => {
        patterns: [
            {
                begin: "{",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.section.block.begin.bracket.curly"
                    }
                },
                end: "}|(?=\\s*#\\s*(?:elif|else|endif)\\b)|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.block.end.bracket.curly"
                    }
                },
                patterns: [
                    {
                        include: "#preprocessor-rule-define-line-blocks"
                    },
                    {
                        include: "#preprocessor-rule-define-line-contents"
                    }
                ]
            },
            {
                include: "#preprocessor-rule-define-line-contents"
            }
        ]
    },
    "preprocessor-rule-define-line-functions" => {
        patterns: [
            {
                include: "#comments-c"
            },
            {
                include: "#storage_types-c"
            },
            {
                include: "#vararg_ellipses-c"
            },
            {
                include: "#access-method"
            },
            {
                include: "#access-member"
            },
            {
                include: "#operators"
            },
            {
                begin: "(?x)\n(?!(?:while|for|do|if|else|switch|catch|return|typeid|alignof|alignas|sizeof|and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas)\\s*\\()\n(\n(?:[A-Za-z_][A-Za-z0-9_]*+|::)++  # actual name\n|\n(?:(?<=operator)(?:[-*&<>=+!]+|\\(\\)|\\[\\]))\n)\n\\s*(\\()",
                beginCaptures: {
                    "1" => {
                        name: "entity.name.function"
                    },
                    "2" => {
                        name: "punctuation.section.arguments.begin.bracket.round"
                    }
                },
                end: "(\\))|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "1" => {
                        name: "punctuation.section.arguments.end.bracket.round"
                    }
                },
                patterns: [
                    {
                        include: "#preprocessor-rule-define-line-functions"
                    }
                ]
            },
            {
                begin: "\\(",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.section.parens.begin.bracket.round"
                    }
                },
                end: "(\\))|(?<!\\\\)(?=\\s*\\n)",
                endCaptures: {
                    "1" => {
                        name: "punctuation.section.parens.end.bracket.round"
                    }
                },
                patterns: [
                    {
                        include: "#preprocessor-rule-define-line-functions"
                    }
                ]
            },
            {
                include: "#preprocessor-rule-define-line-contents"
            }
        ]
    },
    "function-innards-c" => {
        patterns: [
            {
                include: "#comments-c"
            },
            {
                include: "#storage_types-c"
            },
            {
                include: "#operators"
            },
            {
                include: "#vararg_ellipses-c"
            },
            {
                name: "meta.function.definition.parameters",
                begin: "(?x)\n(?!(?:while|for|do|if|else|switch|catch|return|typeid|alignof|alignas|sizeof|and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas)\\s*\\()\n(\n(?:[A-Za-z_][A-Za-z0-9_]*+|::)++ # actual name\n|\n(?:(?<=operator)(?:[-*&<>=+!]+|\\(\\)|\\[\\]))\n)\n\\s*(\\()",
                beginCaptures: {
                    "1" => {
                        name: "entity.name.function"
                    },
                    "2" => {
                        name: "punctuation.section.parameters.begin.bracket.round"
                    },
                },
                end: -/\)|:/,
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.parameters.end.bracket.round"
                    }
                },
                patterns: [
                    {
                        include: "#probably_a_parameter"
                    },
                    {
                        include: "#function-innards-c"
                    }
                ]
            },
            {
                begin: "\\(",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.section.parens.begin.bracket.round"
                    }
                },
                end: "\\)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.parens.end.bracket.round"
                    }
                },
                patterns: [
                    {
                        include: "#function-innards-c"
                    }
                ]
            },
            {
                include: "$base"
            }
        ]
    },
    "function-call-innards-c" => {
        patterns: [
            {
                include: "#comments-c"
            },
            {
                include: "#storage_types-c"
            },
            {
                include: "#access-method"
            },
            {
                include: "#access-member"
            },
            {
                include: "#operators"
            },
            {
                begin: "(?x)\n(?!(?:while|for|do|if|else|switch|catch|return|typeid|alignof|alignas|sizeof|and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|alignof|alignas)\\s*\\()\n(\n(?:new)\\s*(#{-maybe(template_call_match)}) # actual name\n|\n(?:(?<=operator)(?:[-*&<>=+!]+|\\(\\)|\\[\\]))\n)\n\\s*(\\()",
                beginCaptures: {
                    "1" => {
                        name: "keyword.operator.memory.new"
                    },
                    "2" => {
                        patterns: [
                            {
                                include: "#template-call-innards"
                            }
                        ]
                    },
                    "3" => {
                        name: "punctuation.section.arguments.begin.bracket.round"
                    },
                },
                end: "\\)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.arguments.end.bracket.round"
                    }
                },
                patterns: [
                    {
                        include: "#function-call-innards-c"
                    }
                ]
            },
            function_call_tagger,
            {
                begin: "\\(",
                beginCaptures: {
                    "0" => {
                        name: "punctuation.section.parens.begin.bracket.round"
                    }
                },
                end: "\\)",
                endCaptures: {
                    "0" => {
                        name: "punctuation.section.parens.end.bracket.round"
                    }
                },
                patterns: [
                    {
                        include: "#function-call-innards-c"
                    }
                ]
            },
            {
                include: "#block_innards-c"
            }
        ]
    }
}


Dir.chdir __dir__

# Save
cpp_grammar.saveAsYamlTo("./syntaxes/cpp.tmLanguage")
cpp_grammar.saveAsJsonTo("./syntaxes/cpp.tmLanguage")